## 一、使用自定义 Utils 实现对数据库的 CRUD

### 1. Utils  定义

```java
public class JDBCUtils {

	/**
	 * 获取数据库连接
	 * @return
	 */
	public static Connection getConnection() {
		try {
			// 读取配置文件中的内容
			FileInputStream fis = new FileInputStream("jdbc.properties");
			Properties properties = new Properties();
			properties.load(fis);
			String url = properties.getProperty("url");
			String user = properties.getProperty("user");
			String password = properties.getProperty("password");
			String driverClassName = properties.getProperty("driverClassName");
			fis.close();

			// 目的 ：就是为了让com.mysql.jdbc.Driver中的静态代码块执行
			Class.forName(driverClassName);
			// 直接通过DriverManager获取连接
			Connection connection = DriverManager.getConnection(url, user, password);
			
			return connection;
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException();//如果发生异常，终止程序运行。
		}
	}
	
	/**
	 * 关资源
	 * @param connection
	 * @param ps
	 */
	public static void close(Connection connection,PreparedStatement ps){
		if(connection != null){
			try {
				connection.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
		
		if(ps != null){
			try {
				ps.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
	}
	/**
	 * 关资源
	 */
	public static void close(Connection connection, PreparedStatement ps, ResultSet rs) {
		close(connection,ps);
		if(rs != null){
			try {
				rs.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
	}
}
```

### 2.CRUD 实现

```java
/**
 * 通过使用java程序操作数据库
 * 1.先获取数据库的连接对象
 * 2.预编译（会使用占位符） - 获取可以操作数据库的对象
 * 3.给占位符赋值
 * 4.执行sql语句
 * 	 	 execute() : 任何sql语句都可以执行
		 executeQuery() : 可以执行查询语句
		 	注意：会获取ResultSet类型的对象，通过该对象获取返回的数据。
		 executeUpdate() : 可以执行增删改的语句
	5.关闭资源
 */
public class JDBCTest2 {

	/**
	 * 查询数据库中的数据
	 * 
	 * @throws Exception
	 */
	@Test
	public void test4() throws Exception {
		List<Employee> list = new ArrayList<>();
		// 1.先获取数据库的连接
		Connection connection = JDBCUtils.getConnection();
		// 2.预编译 - 获取可以操作数据库的对象
		PreparedStatement ps = connection.prepareStatement("select id,name from employee");
		// 通过ResultSet获取所有的查询结果
		ResultSet rs = ps.executeQuery();
		// next() : 是否有下一条数据，如果有返回true,否则返回false
		while (rs.next()) {
			// 通过指明列的索引值获取对应的数据
			int id = rs.getInt(1);
			// 通过字段名获取对应的数据
			// rs.getInt("id");
			String name = rs.getString(2);
			System.out.println("id=" + id + " name=" + name);
			// 封装对象
			Employee employee = new Employee(id, name);
			list.add(employee);
		}
		// 关资源
		JDBCUtils.close(connection, ps, rs);
	}

	/**
	 * 删除数据
	 * 
	 * @throws Exception
	 */
	@Test
	public void test3() throws Exception {
		// 1.先获取数据库的连接
		Connection connection = JDBCUtils.getConnection();
		// 2.预编译 - 获取可以操作数据库的对象
		// ? : 占位符
		PreparedStatement ps = connection.prepareStatement("delete from employee where id=?");
		// 3.给占位符设置数据
		// setString(int parameterIndex, String x) :
		// parameterIndex ： 指的是占位符的索引位置（从1开始）
		// x : 给占位符的位置赋值的数据
		ps.setInt(1, 2);
		// 4.执行sql命令
		// execute() : 任何sql语句都可以执行
		// executeQuery() : 可以执行查询语句
		// executeUpdate() : 可以执行增删改的语句
		ps.executeUpdate();
		// 5.关闭资源
		JDBCUtils.close(connection, ps);

	}

	/**
	 * 修改数据库中的数据
	 * 
	 * @throws Exception
	 */
	@Test
	public void test2() throws Exception {
		// 1.先获取数据库的连接
		Connection connection = JDBCUtils.getConnection();
		// 2.预编译
		PreparedStatement ps = connection.prepareStatement("UPDATE employee SET NAME=? WHERE id=?");
		// 3.给占位符赋值
		ps.setString(1, "fff");
		ps.setInt(2, 2);
		// 4.执行sql语句
		ps.executeUpdate();
		// 5.关资源
		JDBCUtils.close(connection, ps);
	}

	/**
	 * 向数据库中插入一条数据
	 * 
	 * @throws Exception
	 */
	@Test
	public void test() throws Exception {
		// 1.先获取数据库的连接
		Connection connection = JDBCUtils.getConnection();
		// 2.预编译 - 获取可以操作数据库的对象
		// ? : 占位符
		PreparedStatement ps = connection.prepareStatement("INSERT INTO employee(NAME) VALUES(?)");
		// 3.给占位符设置数据
		// setString(int parameterIndex, String x) :
		// parameterIndex ： 指的是占位符的索引位置（从1开始）
		// x : 给占位符的位置赋值的数据
		ps.setString(1, "abc");
		// 4.执行sql命令
		// execute() : 任何sql语句都可以执行
		// executeQuery() : 可以执行查询语句
		// executeUpdate() : 可以执行增删改的语句
		int executeUpdate = ps.executeUpdate(); // 返回值 ：有多少行数据受到影响
		// 5.关资源
		JDBCUtils.close(connection, ps);
	}
}
```

## 二、数据库事务

```java
public class JDBCTest {

	public static void main(String[] args) {

		/*
		 * 需求 ：要对两个账户进行操作。AA,CC AA给CC转账100块钱。 如果在转账的时候发生了异常那么要求数据恢复原来的状态
		 * 
		 * aa - 100 cc + 100
		 */
		// 1.先获取数据库的连接
		Connection connection = JDBCUtils.getConnection();

		try {
			// 开启事务
			// 1.设置禁止自动提交
			connection.setAutoCommit(false);

			// 预编译
			PreparedStatement ps = connection.prepareStatement("update account set balance=? where name=?");
			ps.setInt(1, 900);
			ps.setString(2, "aa");
			ps.executeUpdate();

			// System.out.println(1 / 0);

			PreparedStatement ps2 = connection.prepareStatement("update account set balance=? where name=?");
			ps2.setInt(1, 1100);
			ps2.setString(2, "cc");
			ps2.executeUpdate();

			// 提效
			connection.commit();

		} catch (Exception e) {
			// 回滚
			try {
				if (connection != null) {
					connection.rollback();
				}
			} catch (SQLException e1) {
				e1.printStackTrace();
			}
		} finally {
			// 关闭资源
			try {
				if (connection != null) {
					connection.close();
				}
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}
	}
}
```

## 三、德鲁伊（Druid）

```java
public class DruidTest {
	
	/**
	 * 方式二
	 * @throws Exception 
	 * @throws FileNotFoundException 
	 */
	@Test
	public void test2() throws FileNotFoundException, Exception{
		
		Properties properties = new Properties();
		properties.load(new FileInputStream("druid.properties"));
		
		//通过读取配置文件的方式创建数据库连接池的对象
		DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);
		//获取数据库连接的对象
		Connection connection = dataSource.getConnection();
		System.out.println(connection);
	}

	/**
	 * 方式一 ：
	 * @throws Exception 
	 */
	@Test
	public void test() throws Exception{
		//获取数据库连接池的对象
		DruidDataSource dataSource = new DruidDataSource();
		//设置对应的参数
		dataSource.setUrl("jdbc:mysql://localhost:3306/xiaolongge");
		dataSource.setUsername("root");
		dataSource.setPassword("root");
		dataSource.setDriverClassName("com.mysql.jdbc.Driver");
		//获取连接
		Connection connection = dataSource.getConnection();
		System.out.println(connection);
	}
}
```

## 四、DBUtils 工具类

使用自定义 Utils 实现对数据库的 CRUD（增强版 —— 二次封装，返回对象）

```java
public class BaseUtils<T> {
	/**
	 * 查询多条数据
	 * @throws SQLException 
	 */
	public List<T> queryList(Connection connection,String sql,Class clazz){
		try {
			QueryRunner qr = new QueryRunner();
			
			List<T> list = qr.query(connection, sql, 
					new BeanListHandler<T>(clazz));
			
			return list;
		} catch (SQLException e) {
			e.printStackTrace();
			throw new RuntimeException();
		}
	}
	
	/**
	 * 可以进行增，删，改的操作
	 * @param connection ： 数据库的连接
	 * @param sql ：执行语句
	 * @param obj ： 给占位符赋值的数据，有几个传几个
	 */
	public  void update(Connection connection,String sql,Object ... obj){
		try {
			QueryRunner qr = new QueryRunner();
			int update = qr.update(connection, sql, obj);
		} catch (SQLException e) {
			e.printStackTrace();
			throw new RuntimeException();
		}
	}
}

// 继承时需要指明泛型类型
public class EmployeeCRUD extends BaseUtils<Employee> {

}

// 测试代码
public class EmployeeTest {

	public static void main(String[] args) {
		
		EmployeeCRUD crud = new EmployeeCRUD();
		
		List<Employee> list = crud.queryList(JDBCUtils.getConnection(),
				"select * from employee", Employee.class);
		
		System.out.println(list);
	}
}

/**
 * Javabean定义：必须是Javabean
 * @author Administrator
 *
 */
public class Employee {

	int id;
	String name;
	
	public Employee(){
		
	}
	
	public Employee(int id, String name) {
		super();
		this.id = id;
		this.name = name;
	}
	
	
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "Employee [id=" + id + ", name=" + name + "]";
	}
}
```

## 五、批处理

```java
public class BatchTest {

	/**
	 * 批处理
	 * 
		注意 ： 1.url设置 ： url=jdbc:mysql://localhost:3306/xiaolongge?rewriteBatchedStatements=true
			 2.mysql驱动包的版本 ： 5.1.3x 才支持批处理
	 */
	@Test
	public void test() throws Exception{
		
		Connection connection = JDBCUtils.getConnection();
		
		PreparedStatement ps = connection.prepareStatement("insert into employee(id,name) values(?,?)");
		
		for (int i = 1; i <= 100000; i++) {
			
			ps.setInt(1, i+1);
			ps.setString(2, i + "ccc");
			
			ps.addBatch();//将该次执行的语句添加到批处理中
			
			if(i % 1000 == 0){
				//执行批处理
				ps.executeBatch();
				//清空批处理
				ps.clearBatch();
			}
		}	
		ps.close();
		connection.close();
	}
}
```

